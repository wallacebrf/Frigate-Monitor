#!/bin/bash
#version 2.0 dated 12/16/2025
#By Brian Wallace


#########################################################
#USER VARIABLES
#########################################################
container_restart_tracker="/mnt/volume1/logging/notifications/frigate_restart_tracker.txt"
log_file_location="/mnt/volume1/logging/notifications"
email_last_sent="$log_file_location/frigate_checker_last_email_sent.txt"
lock_file_location="$log_file_location/frigate_checker.lock"
config_file_location="/mnt/volume1/hosting/web/config/config_files/frigate_checker_config.txt"
camera_name_file_location="/mnt/volume1/hosting/web/config/config_files/frigate_checker_camera_names.txt"
frigate_auth_file="$log_file_location/frigate_auth.txt"
jwt_secret_file_location="/mnt/volume1/apps/figate/config/.jwt_secret"
capture_interval_adjustment=1
debug=0
truenas_multireport_sendemail="/mnt/volume1/logging/multireport_sendemail.py"

#########################################################
#SCRIPT Start
#########################################################


#check that the script is running as root or some of the commands required will not work
if [[ $( whoami ) != "root" ]]; then
	echo -e "ERROR - Script requires ROOT permissions, exiting script"
	exit 1
fi

if [ -d "/mnt/ramfs" ]; then
	echo "RAM disk \"/mnt/ramfs\" Exists"
else
	echo "creating RAM disk \"/mnt/ramfs\""
	mkdir /mnt/ramfs && mount -t tmpfs -o size=100m ramdisk /mnt/ramfs
fi

#check that the required working directory is available, readable, and writable. it should be since we are root, but better check
if [ -d "$log_file_location" ]; then
	if [ -r "$log_file_location" ]; then
		if [ ! -r "$log_file_location" ]; then
			echo -e "ERROR - The script directory \"$log_file_location\" is not writable, exiting script"
			exit 1
		fi
	else
		echo -e "ERROR - The script directory \"$log_file_location\" is not readable, exiting script"
		exit 1
	fi
else
	echo -e "ERROR - The script directory \"$log_file_location\" is not available, exiting script"
	exit 1
fi

#create a lock file in the ramdisk directory to prevent more than one instance of this script from executing at once
if ! mkdir "$lock_file_location"; then
	echo -e "Failed to acquire lock.\n" >&2
	exit 1
fi
trap 'rm -rf $lock_file_location' EXIT #remove the lockdir on exit

#########################################################
#this function is used to send emails
#########################################################
function send_email(){
#email_last_sent_log_file=${1}			this file contains the UNIX time stamp of when the email is sent so we can track how long ago an email was last sent
#message_text=${2}						this string of text contains the body of the email message
#email_subject=${3}						this string of text contains the email subject line
#email_interval=${4}					this numerical value will control how many minutes must pass before the next email is allowed to be sent
	local message_tracker=""
	local time_diff=0
	echo "${2}"
	echo ""
	local current_time=$( date +%s )
	if [ -r "${1}" ]; then #file is available and readable 
		read message_tracker < "${1}"
		time_diff=$((( $current_time - $message_tracker ) / 60 ))
	else
		echo -n "$current_time" > "${1}"
		time_diff=$(( ${4} + 1 ))
	fi
		
	if [ $time_diff -ge ${4} ]; then
		local now=$(date +"%T")
		echo "the email has not been sent in over ${4} minutes, re-sending email"
		address_explode=(`echo "$email_address" | sed 's/;/\n/g'`)
		local bb=0
		for bb in "${!address_explode[@]}"; do
			python3 "$truenas_multireport_sendemail" --subject "${3}" --to_address "${address_explode[$bb]}" --mail_body_html "$now - ${2}" --override_fromemail "$from_email_address"
		done
		message_tracker=$current_time
		time_diff=0
		echo -n "$message_tracker" > "${1}"
	else
		echo "Only $time_diff minuets have passed since the last notification, email will be sent every ${4} minutes. $(( ${4} - $time_diff )) Minutes Remaining Until Next Email"
	fi
}
#########################################################
#this function generates JWT tokens based on the JWT_secret value generated by Frigate
#########################################################
#thanks to the code here
#https://medium.com/@cbarange.dev/build-a-jwt-in-bash-without-dependencies-b9a6cb72d1f7
frigate_auth(){
	if [[ -r "$jwt_secret_file_location" ]]; then
		read JWT_SECRET < "$jwt_secret_file_location"
	else
		echo "Frigate Secret File not Available"
		exit 1
	fi
	base64_urlencode() { openssl enc -base64 -A | tr '+/' '-_' | tr -d '='; }

	  [ -n "$JWT_SECRET" ] || die "JWT_SECRET environment variable is not set."

	  # number of seconds to expire token. default 1h
	  expire_seconds="${JWT_EXPIRATION_IN_SECONDS:-3600}"

	  # pass JWT_SECRET_BASE64_ENCODED as true if secret is base64 encoded
	  ${JWT_SECRET_BASE64_ENCODED:-false} && \
		JWT_SECRET=$(printf %s "$JWT_SECRET" | base64 --decode)

	  header='{
		"alg": "HS256",
		"typ": "JWT"
	  }'

	  payload="{
		\"sub\": \"user\",
		\"iat\": $(date +%s),
		\"exp\": $(($(date +%s)+expire_seconds)),
		\"role\": \"role\"
	  }"

	  header_base64=$(printf %s "$header" | base64_urlencode)
	  payload_base64=$(printf %s "$payload" | base64_urlencode)
	  signed_content="${header_base64}.${payload_base64}"
	  signature=$(printf %s "$signed_content" | openssl dgst -binary -sha256 -hmac "$JWT_SECRET" | base64_urlencode)

	  #uncomment to see the token value generated
	  printf '%s' "${signed_content}.${signature}"
}

#########################################################
#read in config file data
#########################################################

if [[ -r "$config_file_location" ]]; then
	#files are available and readable 
	read input_read < "$config_file_location"
	explode=(`echo $input_read | sed 's/,/\n/g'`)
	
	#verify the correct number of configuration parameters are in the configuration file
	if [[ ! ${#explode[@]} == 16 ]]; then
		echo "config file corrupt, exiting script"
		exit 1
	fi	

	email_address=${explode[0]}
	from_email_address=${explode[1]}
	max_allowed_memory=${explode[2]}
	restart_hour=${explode[3]}
	minimum_time_between_restarts=${explode[4]}
	docker_container_name=${explode[5]}
	truenas_container_name=${explode[6]}
	nas_name=${explode[7]}
	frigate_address=${explode[8]}
	script_enable=${explode[9]}
	capture_interval=${explode[10]}
	influxdb_host=${explode[11]}
	influxdb_port=${explode[12]}
	influxdb_name=${explode[13]}
	influxdb_org=${explode[14]}
	influxdb_pass=${explode[15]}
	
#########################################################
#actually start the script execution
#########################################################

	if [ $script_enable -eq 1 ]; then
		current_time_min=$(date +"%M")
		
		#read in the configured cameras on the system
		if [[ -r "$camera_name_file_location" ]]; then
			#files are available and readable 
			read input_read < "$camera_name_file_location"
			camera_name=(`echo $input_read | sed 's/,/\n/g'`)
			echo "${#camera_name[@]} Cameras Configured"
		else
			echo "Camera Name File Missing, exiting script"
			exit 1
		fi
		
		#########################################################
		#Frigate Memory Restart Threshold Status
		#########################################################
		
		#Frigate seems to have a tendency to slowly use more and more RAM over time
		#This portion of the script monitors the used memory of the Frigate container and if the memory exceeds a configurable value, the Frigate container will be Restarted
		#the restart is only allowed to occur at a set hour of the day, typically 1:00AM or 2:00 AM when less activity is likely to occur reducing chances of loosing recordings of something important

		mem_status=$(docker stats $docker_container_name --format "{{.MemUsage}}" --no-stream)
		explode=(`echo $mem_status | sed 's/,/ /g'`)

		if [[ ${explode[0]} =~ "GiB" ]]; then  #only worry if we are using GB and not MB worth of memory
			mem_used=${explode[0]}
			mem_used=$(echo "${mem_used::-3}")		#removing the "GiB" from the end of the line
			echo -e "\n\n_______________________________________\nFrigate Memory Restart Threshold Status\n_______________________________________"
			echo "-->Currently Used Memory: $mem_used GB"
			mem_used=$(printf "%.0f\n" "${mem_used}e2") #multiply by 100 to get rid of decimal places since trueNAS does not have "bc" installed

			mem_total=${explode[2]}
			mem_total=$(echo "${mem_total::-3}")
			echo "-->Total Memory Assigned to Container: $mem_total GB"
			mem_total=$(printf "%.0f\n" "${mem_total}e2") #multiply by 100 to get rid of decimal places
			
			echo "-->Memory Usage Restart Threshold: $max_allowed_memory GB"
			
			max_allowed_memory=$(printf "%.0f\n" "${max_allowed_memory}e2")

			if [[ $mem_used -ge $max_allowed_memory ]]; then
			
				current_time=$( date +%s )	
				if [ -r "$container_restart_tracker" ]; then
					read delay_status < "$container_restart_tracker"
					delay_time_diff=$(( $current_time - $delay_status ))
				else 
					echo "$current_time" > "$container_restart_tracker"
					delay_time_diff=$(( $minimum_time_between_restarts + 1 ))
				fi
				
				if [ $delay_time_diff -ge $minimum_time_between_restarts ]; then
					current_time_hour=$(date +"%H")
						
					if [ "$current_time_hour" == "$restart_hour" ]; then
						echo "-->Restarting Frigate"
						
						app_installed=0
						app_state=0
						app_stopped=0
						current_app_status=$(midclt call app.query '[["name", "=", "'$truenas_container_name'"]]' | jq -r '.[] | .state')
						
						#determine if the app is installed and if it is installed determine its running state so we can maintain the current state after the backup is complete
						if [[ "$current_app_status" == "" ]]; then #app is not installed
							echo "-->TrueNAS Application \"$truenas_container_name\" is NOT installed, exiting script"
							exit 1
						elif [[ "$current_app_status" == "RUNNING" ]]; then #app is installed and running
							app_installed=1
							app_state=1
							echo "-->TrueNAS Application \"$truenas_container_name\" is installed and running"
						elif [[ "$current_app_status" == "STOPPED" ]]; then #app is installed and stopped
							echo "-->TrueNAS Application \"$truenas_container_name\" is installed but currently stopped, exiting script"
							exit 1
						fi
						
						if [[ $app_installed -eq 1 ]]; then #is app installed
							if [[ $app_state -eq 1 ]]; then #app was found in the running state
								echo "-->Stopping Application \"$truenas_container_name\""
								midclt call app.stop "$truenas_container_name"
								echo "-->Waiting 60 seconds for app to stop" #the midclt command returns a value immediately even though the app is not yet stopped
								sleep 10
								echo "-->50 seconds remaining"
								sleep 10
								echo "-->40 seconds remaining"
								sleep 10
								echo "-->30 seconds remaining"
								sleep 10
								echo "-->20 seconds remaining"
								sleep 10
								echo "-->10 seconds remaining"
								sleep 10
								if [ "$( midclt call app.query '[["name", "=", "'$truenas_container_name'"]]' | jq -r '.[] | .state' )" == "STOPPED" ]; then #app is installed and stopped
									echo "-->Application \"$truenas_container_name\" Successfully Stopped"
									app_stopped=1
								else
									echo "-->Application \"$truenas_container_name\" Failed to Stop "
									app_stopped=0
									echo "$current_time" > "$container_restart_tracker"
									send_email "$email_last_sent" "Frigate Restart Failed. Unable to Stop Container" "Frigate Restart Failed" 60
								fi
							fi
							
							if [[ $app_stopped -eq 1 ]]; then	#we successfully stopped the app, let's restart it
								echo "-->Starting Application \"$truenas_container_name\""
								midclt call app.start "$truenas_container_name"
								echo "-->Waiting 60 seconds for app to start" #the midclt command returns a value immediately even though the app is not yet started
								sleep 10
								echo "-->50 seconds remaining"
								sleep 10
								echo "-->40 seconds remaining"
								sleep 10
								echo "-->30 seconds remaining"
								sleep 10
								echo "-->20 seconds remaining"
								sleep 10
								echo "-->10 seconds remaining"
								sleep 10
								if [ "$( midclt call app.query '[["name", "=", "'$truenas_container_name'"]]' | jq -r '.[] | .state' )" == "RUNNING" ]; then #app is installed and running
									echo "-->Application \"$truenas_container_name\" Successfully Started"
									send_email "$email_last_sent" "Frigate Restarted Due to Excessive Memory Usage" "Frigate Restarted" 60
									echo "$current_time" > "$container_restart_tracker"
								else
									echo "-->Application \"$truenas_container_name\" Failed to Start"
									echo "$current_time" > "$container_restart_tracker"
									send_email "$email_last_sent" "Frigate Restart Failed. Unable to Restart Container" "Frigate Restart Failed" 60
								fi
							fi
						fi	
					else
						echo "-->Memory Threshold Exceeded, Not Correct Time of Day To Restart Frigate. Frigate will be restarted at $restart_hour hours"
					fi
				else
					echo "-->Not Enough Time Has Elapsed Since Last Frigate Restart"
				fi
			else
				echo "-->Frigate Memory Acceptable"
			fi	
		fi
		
		#########################################################
		#Frigate Metrics Logging
		#########################################################
		
		#this portion of the script scrapes data off the /api/metrics page of Frigate while using proper authentication tokens. 
		#the scrapped data is then saved to InfluxDB
		
		if [ ! $capture_interval -eq 10 ]; then
			if [ ! $capture_interval -eq 15 ]; then
				if [ ! $capture_interval -eq 30 ]; then
					if [ ! $capture_interval -eq 60 ]; then
						echo "-->capture interval is not one of the allowable values of 10, 15, 30, or 60 seconds. Exiting the script"
						exit 1
					fi
				fi
			fi
		fi

		#loop the script 
		total_executions=$(( 60 / $capture_interval))
		echo -e "\n\n_______________________________________\nFrigate Metrics Logging\n_______________________________________"
		echo "-->Capturing $total_executions times"
		i=0
		while [ $i -lt $total_executions ]; do
		
			current_time=$( date +%s )
			
			#########################################
			#Authenticate with Frigate for API access
			#########################################
			
			#get previously created authentication token information from the last script execution
			if [[ -r "$frigate_auth_file" ]]; then
				#files are available and readable 
				read input_read < "$frigate_auth_file"
				explode=(`echo $input_read | sed 's/,/\n/g'`)
				frigate_token=${explode[0]}
				auth_failure=${explode[1]}
				auth_failure_last_recorded=${explode[2]}
			else
				#file does not exist, save default values into it
				frigate_token=$(frigate_auth) #get new auth token
				auth_failure=0
				auth_failure_last_recorded=$current_time
				echo "$frigate_token,0,$current_time" > "$frigate_auth_file"
			fi
			
			if [[ $auth_failure -eq 0 ]]; then
				#get data from Frigate
				raw_metrics=$(curl -sS -X GET "$frigate_address" -H "Authorization: Bearer $frigate_token" -H "Accept: application/json" 2>&1 | sed '/^#/d')

				#validate if Frigate is responding as it may be off line
				if [[ "$(echo -n "$raw_metrics" | grep "Failed")" != "" ]]; then	
					if [ ! -r "$log_file_location/frigate_error.txt" ]; then
						now=$(date)
						echo "$now" > "$log_file_location/frigate_error.txt"
						send_email "$email_last_sent" "WARNING - Frigate NVR is not responding." "Frigate OFFLINE" 0
					fi 
					exit 1
				else
					if [ -r "$log_file_location/frigate_error.txt" ]; then
						send_email "$email_last_sent" "Frigate NVR has resumed normal operations." "Frigate ONLINE" 0
						rm "$log_file_location/frigate_error.txt"
					fi 
				fi
				
				#validate if we have successfully authenticated
				if [[ "$(echo -n "$raw_metrics" | grep "401 Authorization Required")" != "" ]]; then
					#auth expired/rejected, get a new token as tokens are expected to expire every hour
					frigate_token=$(frigate_auth)
					#send_email "$email_last_sent" "Frigate Authorization Token Renewed. New Token is:<br><br>$frigate_token" "Frigate Authorization Refreshed" 0
					
					#re-try authentication with the new token
					raw_metrics=$(curl -sS -X GET "$frigate_address" -H "Authorization: Bearer $frigate_token" -H "Accept: application/json" 2>&1 | sed '/^#/d')
					
					if [[ "$(echo -n "$raw_metrics" | grep "401 Authorization Required")" != "" ]]; then
						send_email "$email_last_sent" "Frigate Authorization Token Failed, Unable to Successfully Generate New Token. Unable to Log Frigate Metrics. Will try again in 60 minuets" "Frigate Authorization Failed" 0
						auth_failure_last_recorded=$current_time
						echo "$frigate_token,1,$auth_failure_last_recorded" > "$frigate_auth_file"
						exit 1
					else
						#auth worked, save the values
						echo "$frigate_token,0,$auth_failure_last_recorded" > "$frigate_auth_file"
					fi
				fi
			else
				#if an auth failure previously occurred, wait 60 minutes to try again by resetting the auth failure flag
				time_diff=$((( $current_time - $auth_failure_last_recorded ) / 60 ))
				if [ $time_diff -ge 60 ]; then
					echo "$frigate_token,0,$auth_failure_last_recorded" > "$frigate_auth_file"
				fi
				exit 1
			fi
				
			
			#Create empty URL
			post_url=
			
			#########################################
			#GETTING VARIOUS SYSTEM INFORMATION
			#########################################
			measurement="Frigate_Metrics"			
			
			#Single line results not needing additional processing
			process_virtual_memory_bytes=$(echo "$raw_metrics" | grep "process_virtual_memory_bytes")
			process_virtual_memory_bytes=$(echo "${process_virtual_memory_bytes##* }")

			process_resident_memory_bytes=$(echo "$raw_metrics" | grep "process_resident_memory_bytes")
			process_resident_memory_bytes=$(echo "${process_resident_memory_bytes##* }")

			process_start_time_seconds=$(echo "$raw_metrics" | grep "process_start_time_seconds")
			process_start_time_seconds=$(echo "${process_start_time_seconds##* }")

			process_cpu_seconds_total=$(echo "$raw_metrics" | grep "process_cpu_seconds_total")
			process_cpu_seconds_total=$(echo "${process_cpu_seconds_total##* }")

			process_open_fds=$(echo "$raw_metrics" | grep "process_open_fds")
			process_open_fds=$(echo "${process_open_fds##* }")

			process_max_fds=$(echo "$raw_metrics" | grep "process_max_fds")
			process_max_fds=$(echo "${process_max_fds##* }")

			frigate_detection_total_fps=$(echo "$raw_metrics" | grep "frigate_detection_total_fps")
			frigate_detection_total_fps=$(echo "${frigate_detection_total_fps##* }")

			frigate_gpu_usage_percent=$(echo "$raw_metrics" | grep "frigate_gpu_usage_percent")
			frigate_gpu_usage_percent=$(echo "${frigate_gpu_usage_percent##* }")

			frigate_gpu_mem_usage_percent=$(echo "$raw_metrics" | grep "frigate_gpu_mem_usage_percent")
			frigate_gpu_mem_usage_percent=$(echo "${frigate_gpu_mem_usage_percent##* }")

			frigate_service_uptime_seconds=$(echo "$raw_metrics" | grep "frigate_service_uptime_seconds")
			frigate_service_uptime_seconds=$(echo "${frigate_service_uptime_seconds##* }")

			frigate_service_last_updated_timestamp=$(echo "$raw_metrics" | grep "frigate_service_last_updated_timestamp")
			frigate_service_last_updated_timestamp=$(echo "${frigate_service_last_updated_timestamp##* }")

			
			post_url=$post_url"$measurement,nas_name=$nas_name,metric=system process_virtual_memory_bytes=$process_virtual_memory_bytes,process_resident_memory_bytes=$process_resident_memory_bytes,process_start_time_seconds=$process_start_time_seconds,process_cpu_seconds_total=$process_cpu_seconds_total,process_open_fds=$process_open_fds,process_max_fds=$process_max_fds,frigate_detection_total_fps=$frigate_detection_total_fps,frigate_gpu_usage_percent=$frigate_gpu_usage_percent,frigate_gpu_mem_usage_percent=$frigate_gpu_mem_usage_percent,frigate_service_uptime_seconds=$frigate_service_uptime_seconds,frigate_service_last_updated_timestamp=$frigate_service_last_updated_timestamp
	"
			
			#multi-line (4x lines) returned results structures as
				#frigate_storage_XYZ{storage="/media/frigate/recordings"} VALUE
				#frigate_storage_XYZ{storage="/media/frigate/clips"} VALUE
				#frigate_storage_XYZ{storage="/tmp/cache"} VALUE
				#frigate_storage_XYZ{storage="/dev/shm"} VALUE
			
			#####################################
			#frigate_storage_free_bytes
			#####################################
			counter=0
			while IFS= read -r line; do	
				storage_free_path=$(echo "${line% *}") #keeps everything to the left of the value
				storage_free_path=$(echo "${storage_free_path::-2}") #removes the "} at the end
				storage_free_path=$(echo "${storage_free_path#*/}") #keeps everything after the first /
				storage_free_path=${storage_free_path//\//_} #replaces the / with _
				
				storage_free_value=$(echo "${line##* }") #stores just the value at the end as it is after the only space char in the string
				
				post_url=$post_url"$measurement,nas_name=$nas_name,metric=storage_free_bytes $storage_free_path=$storage_free_value
	"
				
				let counter=counter+1
			done <<< $(echo "$raw_metrics" | grep "frigate_storage_free_bytes")
			
			#####################################
			#frigate_storage_total_bytes
			#####################################
			counter=0
			while IFS= read -r line; do	
				storage_total_path=$(echo "${line% *}") #keeps everything to the left of the value
				storage_total_path=$(echo "${storage_total_path::-2}") #removes the "} at the end
				storage_total_path=$(echo "${storage_total_path#*/}") #keeps everything after the first /
				storage_total_path=${storage_total_path//\//_} #replaces the / with _
				
				storage_total_value=$(echo "${line##* }") #stores just the value at the end as it is after the only space char in the string
				
				post_url=$post_url"$measurement,nas_name=$nas_name,metric=storage_total_bytes $storage_total_path=$storage_total_value
	"
				
				let counter=counter+1
			done <<< $(echo "$raw_metrics" | grep "frigate_storage_total_bytes")
			
			#####################################
			#frigate_storage_used_bytes
			#####################################
			counter=0
			while IFS= read -r line; do	
				storage_used_path=$(echo "${line% *}") #keeps everything to the left of the value
				storage_used_path=$(echo "${storage_used_path::-2}") #removes the "} at the end
				storage_used_path=$(echo "${storage_used_path#*/}") #keeps everything after the first /
				storage_used_path=${storage_used_path//\//_} #replaces the / with _
				
				storage_used_value=$(echo "${line##* }") #stores just the value at the end as it is after the only space char in the string
				
				post_url=$post_url"$measurement,nas_name=$nas_name,metric=storage_used_bytes $storage_used_path=$storage_used_value
	"
				let counter=counter+1
			done <<< $(echo "$raw_metrics" | grep "frigate_storage_used_bytes")
			
			#Multi-line returned value depending on quantity of detectors configured
			#####################################
			#frigate_detector_inference_speed_seconds
			#####################################
			counter=0
			while IFS= read -r line; do	
				frigate_detector_name=$(echo "${line% *}") #keeps everything to the left of the value
				frigate_detector_name=$(echo "${frigate_detector_name::-2}") #removes the "} at the end
				frigate_detector_name=$(echo "${frigate_detector_name#*\"}") #keeps everything after the first /
				frigate_detector_name=${frigate_detector_name//\//_} #replaces the / with _
				
				frigate_detector_inference_speed_seconds=$(echo "${line##* }") #stores just the value at the end as it is after the only space char in the string
				
				post_url=$post_url"$measurement,nas_name=$nas_name,metric=inference_speed $frigate_detector_name=$frigate_detector_inference_speed_seconds
	"
				let counter=counter+1
			done <<< $(echo "$raw_metrics" | grep "frigate_detector_inference_speed_seconds")
			
			#####################################
			#frigate_detection_start
			#####################################
			counter=0
			while IFS= read -r line; do	
				frigate_detector_name=$(echo "${line% *}") #keeps everything to the left of the value
				frigate_detector_name=$(echo "${frigate_detector_name::-2}") #removes the "} at the end
				frigate_detector_name=$(echo "${frigate_detector_name#*\"}") #keeps everything after the first /
				frigate_detector_name=${frigate_detector_name//\//_} #replaces the / with _
				
				frigate_detection_start=$(echo "${line##* }") #stores just the value at the end as it is after the only space char in the string
				
				post_url=$post_url"$measurement,nas_name=$nas_name,metric=detection_start $frigate_detector_name=$frigate_detection_start
	"
				let counter=counter+1
			done <<< $(echo "$raw_metrics" | grep "frigate_detection_start")
			
			#####################################
			#CAMERA LEVEL METRICS
			#####################################
			#Multi-line returned value depending on quantity of cameras configured
			counter=0
			for counter in "${!camera_name[@]}"; do
				frigate_audio_dBFS=$(echo "$raw_metrics" | grep "frigate_audio_dBFS" | grep "${camera_name[$counter]}")
				frigate_audio_dBFS=$(echo "${frigate_audio_dBFS##* }") #stores just the value at the end as it is after the only space char in the string
				
				frigate_audio_rms=$(echo "$raw_metrics" | grep "frigate_audio_rms" | grep "${camera_name[$counter]}")
				frigate_audio_rms=$(echo "${frigate_audio_rms##* }") #stores just the value at the end as it is after the only space char in the string
				
				frigate_camera_fps=$(echo "$raw_metrics" | grep "frigate_camera_fps" | grep "${camera_name[$counter]}")
				frigate_camera_fps=$(echo "${frigate_camera_fps##* }") #stores just the value at the end as it is after the only space char in the string
				
				frigate_detection_fps=$(echo "$raw_metrics" | grep "frigate_detection_fps" | grep "${camera_name[$counter]}")
				frigate_detection_fps=$(echo "${frigate_detection_fps##* }") #stores just the value at the end as it is after the only space char in the string
				
				frigate_process_fps=$(echo "$raw_metrics" | grep "frigate_process_fps" | grep "${camera_name[$counter]}")
				frigate_process_fps=$(echo "${frigate_process_fps##* }") #stores just the value at the end as it is after the only space char in the string
				
				frigate_skipped_fps=$(echo "$raw_metrics" | grep "frigate_skipped_fps" | grep "${camera_name[$counter]}")
				frigate_skipped_fps=$(echo "${frigate_skipped_fps##* }") #stores just the value at the end as it is after the only space char in the string
				
				post_url=$post_url"$measurement,nas_name=$nas_name,metric=camera_details,camera=${camera_name[$counter]} frigate_audio_dBFS=$frigate_audio_dBFS,frigate_audio_rms=$frigate_audio_rms,frigate_camera_fps=$frigate_camera_fps,frigate_detection_fps=$frigate_detection_fps,frigate_process_fps=$frigate_process_fps,frigate_skipped_fps=$frigate_skipped_fps
	"
			done
			
			

			if [[ $debug -eq 1 ]]; then
				echo "$post_url"
			fi
			
			echo "$post_url" > "/mnt/ramfs/frigate_logging.txt"
					
			curl -XPOST "http://$influxdb_host:$influxdb_port/api/v2/write?bucket=$influxdb_name&org=$influxdb_org" -H "Authorization: Token $influxdb_pass" --data-binary "@/mnt/ramfs/frigate_logging.txt"
					
			let i=i+1
			echo "-->Capture #$i complete"
					
			#Sleeping for capture interval unless its last capture then we dont sleep
			if (( $i < $total_executions)); then
				sleep $(( $capture_interval - $capture_interval_adjustment ))
			fi
		done
		
		#########################################################
		#Frigate Camera Operational Status Checker
		#########################################################
		
		#This portion of the script looks at the number of received frames from each camera and if the frames are 0.0, then the camera is off line or malfunctioning
		#the script will then send emails per camera to inform the user that something is wrong with that particular camera
		#when any particular camera is back on line the script will send a new email informing the user the particular camera is back on line. 
		#this portion of the script only runs every five minutes to add hysteresis to prevent floods of emails if a camera is acting flaky. 
		
		echo -e "\n\n_______________________________________\nFrigate Camera Operational Status Checker\n_______________________________________"
		if [ "$current_time_min" == "00" ] || [ "$current_time_min" == "05" ] || [ "$current_time_min" == "10" ] || [ "$current_time_min" == "15" ] || [ "$current_time_min" == "20" ] || [ "$current_time_min" == "25" ] || [ "$current_time_min" == "30" ] || [ "$current_time_min" == "35" ] || [ "$current_time_min" == "40" ] || [ "$current_time_min" == "45" ] || [ "$current_time_min" == "50" ] || [ "$current_time_min" == "55" ]; then
			####################################
			#check if any cameras are not responding
			####################################
			post_url=$(echo "$raw_metrics" | grep "frigate_camera_fps")
				
			camera_dead=$(echo "$post_url" | grep "0.0")
						
			if [[ $debug -eq 1 ]]; then
				echo -e "-->Current Camera Frames Per Second:\n\n"
				echo "$post_url"
				echo -e "\n\n"
			fi
								
			if [[ "$camera_dead" != "" ]]; then #if text was found, then a camera is reporting 0.0 frames, we want no text to be found by grep
				if [[ $debug -eq 1 ]]; then
					echo -e "Current Camera(s) Not Responding:\n_________________________________\n\n"
				fi
				counter=0
				for counter in "${!camera_name[@]}"; do
					if [[ "$(echo -n "$camera_dead" | grep "${camera_name[$counter]}")" != "" ]]; then #if the name of the current camera is the one with 0.0 frames, then we have a bad camera. no text during grep means the camera is good
						if [ ! -r "$log_file_location/${camera_name[$counter]}_error.txt" ]; then
							send_email "$email_last_sent" "Attention - Camera \"${camera_name[$counter]}\" is not responding and Frigate is not consuming any frames from this camera." "Frigate Camera \"${camera_name[$counter]}\" Down" 0
							now=$(date)
							echo "$now" > "$log_file_location/${camera_name[$counter]}_error.txt"
							echo "--> Camera \"${camera_name[$counter]}\" is not responding"
						fi
					else #if the particular camera name is no longer reporting 0.0 frames, but one or more different camera(s) are reporting 0.0 frames, remove the log file for the now good camera
						if [ -r "$log_file_location/${camera_name[$counter]}_error.txt" ]; then
							send_email "$email_last_sent" "Camera \"${camera_name[$counter]}\" has resumed normal operation." "Frigate Camera \"${camera_name[$counter]}\" ONLINE" 0
							rm "$log_file_location/${camera_name[$counter]}_error.txt"
							echo "--> Camera \"${camera_name[$counter]}\" has resumed normal operation"
						fi
					fi
				done
			else #all cameras appear to be working, delete all log files to mark the cameras as good
				counter=0
				echo -e "--> All Cameras Operating Normally\n\n"
				for counter in "${!camera_name[@]}"; do
					if [ -r "$log_file_location/${camera_name[$counter]}_error.txt" ]; then
						send_email "$email_last_sent" "Camera \"${camera_name[$counter]}\" has resumed normal operation." "Frigate Camera \"${camera_name[$counter]}\" ONLINE" 0
						rm "$log_file_location/${camera_name[$counter]}_error.txt"
					fi
				done
			fi
		else
			echo -e "-->Frigate Camera Operational Status Checker Occurs Every Five Minuets\n\n"
		fi
	else
		echo "script is disabled"
	fi
else
	echo "configuration file is missing, exiting script"
	exit 1
fi
